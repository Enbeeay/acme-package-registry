#!/usr/bin/env python3
import os
import sys
import subprocess
import typer
from src.logging_config import setup_logging

app = typer.Typer(add_completion=False)


# if the first CLI arg is an existing file, dispatch to process_cmd before Typer parses commands
# This allows `./run URL_FILE` to work.
def _dispatch_file_arg():
    if len(sys.argv) >= 2:
        first = sys.argv[1]
        if os.path.isabs(first):
            candidate = first
        else:
            candidate = os.path.join(os.getcwd(), first)
        if os.path.exists(candidate) and os.path.isfile(candidate):
            process_cmd(candidate)

@app.command()
def install():
    try:
        subprocess.check_call([sys.executable, '-m', 'pip', 'install', '--user', '-r', 'requirements.txt'])
    except subprocess.CalledProcessError as e:
        typer.echo(f"Install failed: {e}", err=True)
        raise typer.Exit(1)
    raise typer.Exit(0)


@app.command()
def test():
    try:
        result = subprocess.run([sys.executable, '-m', 'pytest', '--cov=src', '--cov-report=term-missing'])
        raise typer.Exit(result.returncode)
    except Exception as e:
        typer.echo(f"Test failed: {e}", err=True)
        raise typer.Exit(1)


@app.command(name='process')
def process_cmd(url_file: str = typer.Argument(..., help='Path to file with URLs')):
    setup_logging()
    # TODO: Implement orchestration logic
    print(f"Processing {url_file}")
    raise typer.Exit(0)


# dispatch to `process_cmd` for standalone URL_FILE is handled by the `_dispatch_file_arg()` pre-check above. We keep commands simple.
_dispatch_file_arg()


if __name__ == '__main__':
    app()
